import React, { useState, useEffect } from 'react';
import './App.css';

function App() {
  // Hardcoded API key - REPLACE THIS WITH YOUR ACTUAL API KEY
  const apiKey = "AIzaSyBVjnegwnKaMYA3qrQD5fZaLqPEepHI6SA"; // Replace with your actual API key
  
  // User state
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [currentUser, setCurrentUser] = useState(null);
  const [users, setUsers] = useState(() => {
    const savedUsers = localStorage.getItem('users');
    return savedUsers ? JSON.parse(savedUsers) : [];
  });
  const [showLeaderboard, setShowLeaderboard] = useState(false);
  
  // State hooks
  const [loading, setLoading] = useState(false);
  const [darkMode, setDarkMode] = useState(false);
  const [gameOver, setGameOver] = useState(false);
  const [won, setWon] = useState(false);
  
  // Game states
  const [word, setWord] = useState('');
  const [hint, setHint] = useState('');
  const [guessedLetters, setGuessedLetters] = useState([]);
  const [wrongGuesses, setWrongGuesses] = useState(0);
  const [score, setScore] = useState(0);
  const [totalGames, setTotalGames] = useState(0);
  const [difficulty, setDifficulty] = useState('medium'); // 'easy', 'medium', 'hard'
  const [usedHints, setUsedHints] = useState([]);
  const [revealedLetters, setRevealedLetters] = useState([]);
  const [usedWords, setUsedWords] = useState(() => {
    const savedWords = localStorage.getItem('usedWords');
    return savedWords ? JSON.parse(savedWords) : [];
  });
  
  // Maximum number of wrong guesses allowed based on difficulty
  const MAX_WRONG_GUESSES_MAP = {
    easy: 8,
    medium: 6,
    hard: 4
  };
  
  // Points per win based on difficulty
  const POINTS_MAP = {
    easy: 1,
    medium: 3,
    hard: 5
  };
  
  // Get current max wrong guesses
  const MAX_WRONG_GUESSES = MAX_WRONG_GUESSES_MAP[difficulty];
  
  // Available letters for keyboard
  const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');
  
  // Array of disaster topics to randomly cycle through
  const disasterTopics = [
    'General Disaster Preparedness',
    'Earthquake Safety',
    'Flood Response',
    'Hurricane/Typhoon Preparedness',
    'Fire Safety',
    'Tsunami Awareness',
    'Drought Management',
    'Pandemic Preparedness',
    'First Aid and Medical Emergency',
    'Emergency Communication',
    'Evacuation Planning',
    'Emergency Supplies'
  ];

  // Add this new state
  const [selectedTopic, setSelectedTopic] = useState('random');
  const [showTopicSelector, setShowTopicSelector] = useState(false);

  // Add new state for hints
  const [availableHints, setAvailableHints] = useState(0);
  
  // Cost of each hint type
  const HINT_COSTS = {
    REVEAL_LETTER: 3,
    ELIMINATE_OPTIONS: 2
  };

  // Add new state for sound settings
  const [soundEnabled, setSoundEnabled] = useState(true);

  // Add new state for educational content
  const [factContent, setFactContent] = useState('');
  const [showFactModal, setShowFactModal] = useState(false);

  // Add new state for glossary
  const [showGlossary, setShowGlossary] = useState(false);
  const [glossaryTerms, setGlossaryTerms] = useState([]);
  const [loadingGlossary, setLoadingGlossary] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');

  // Audio elements for preloading sounds
  const audioElements = {
    correct: null,
    wrong: null,
    win: null,
    lose: null,
    click: null,
    achievement: null
  };

  // Music state
  const [backgroundMusic, setBackgroundMusic] = useState(null);
  const [musicEnabled, setMusicEnabled] = useState(true);
  const [currentTrack, setCurrentTrack] = useState(0);
  const [musicVolume, setMusicVolume] = useState(0.5);
  // const [showMusicControls, setShowMusicControls] = useState(false);

  // Music tracks collection
  const musicTracks = [
    {
      name: "Calm Ambience",
      url: "./audio/calm-ambience.mp3"
    }
  ];

  // Add achievements state
  const [achievements, setAchievements] = useState(() => {
    const savedAchievements = localStorage.getItem('achievements');
    return savedAchievements ? JSON.parse(savedAchievements) : {};
  });
  const [showAchievements, setShowAchievements] = useState(false);

  // Define achievements
  const ACHIEVEMENTS = {
    FIRST_WIN: {
      id: 'first_win',
      title: 'First Victory',
      description: 'Win your first game',
      icon: 'ðŸ†',
      points: 5
    },
    PERFECT_GAME: {
      id: 'perfect_game',
      title: 'Perfect Game',
      description: 'Win a game without any wrong guesses',
      icon: 'â­',
      points: 10
    },
    STREAK_3: {
      id: 'streak_3',
      title: 'Winning Streak',
      description: 'Win 3 games in a row',
      icon: 'ðŸ”¥',
      points: 15
    },
    HINT_MASTER: {
      id: 'hint_master',
      title: 'Hint Master',
      description: 'Use both types of hints in a single game',
      icon: 'ðŸ’¡',
      points: 5
    },
    HARD_MODE: {
      id: 'hard_mode',
      title: 'Challenge Accepted',
      description: 'Win a game on hard difficulty',
      icon: 'ðŸ”¨',
      points: 20
    }
  };

  // Load preferences and user data from localStorage on component mount and generate first word
  useEffect(() => {
    const savedDarkMode = localStorage.getItem('darkMode') === 'true';
    setDarkMode(savedDarkMode);
    
    if (savedDarkMode) {
      document.body.classList.add('dark-mode');
    }
    
    // Load sound and music preferences
    const savedSoundEnabled = localStorage.getItem('soundEnabled') !== 'false'; // Default to true
    setSoundEnabled(savedSoundEnabled);
    
    const savedMusicEnabled = localStorage.getItem('musicEnabled') !== 'false'; // Default to true
    setMusicEnabled(savedMusicEnabled);
    
    const savedMusicVolume = 0.5; // Set to 50% volume
    setMusicVolume(savedMusicVolume);
    
    // Always use track 0 now that we only have one track
    setCurrentTrack(0);
    
    // Preload sounds
    if (savedSoundEnabled) {
      preloadSounds();
    }
    
    // Initialize background music only if enabled
    if (savedMusicEnabled) {
      console.log("Music is enabled in initial load, initializing...");
      setTimeout(() => {
        initBackgroundMusic(0, savedMusicVolume);
      }, 1000); // Add a slight delay to ensure all states are properly set
    } else {
      console.log("Music is disabled in initial load, skipping initialization");
    }
    
    // Load users
    const savedUsers = localStorage.getItem('users');
    if (savedUsers) {
      setUsers(JSON.parse(savedUsers));
    }
    
    // Check for logged in user
    const savedUser = localStorage.getItem('currentUser');
    if (savedUser) {
      const parsedUser = JSON.parse(savedUser);
      setCurrentUser(parsedUser);
      setScore(parsedUser.score || 0);
      setTotalGames(parsedUser.totalGames || 0);
      setIsLoggedIn(true);
    }
    
    // Cleanup background music on component unmount
    return () => {
      if (backgroundMusic) {
        backgroundMusic.pause();
        backgroundMusic.src = '';
      }
    };
  }, []);

  // Save users to localStorage
  useEffect(() => {
    if (users.length > 0) {
      localStorage.setItem('users', JSON.stringify(users));
    }
  }, [users]);

  // Save usedWords to localStorage when it changes
  useEffect(() => {
    if (usedWords.length > 0) {
      localStorage.setItem('usedWords', JSON.stringify(usedWords));
    }
  }, [usedWords]);

  // Save achievements to localStorage when they change
  useEffect(() => {
    localStorage.setItem('achievements', JSON.stringify(achievements));
  }, [achievements]);

  // Toggle dark mode
  const toggleDarkMode = () => {
    const newDarkMode = !darkMode;
    setDarkMode(newDarkMode);
    localStorage.setItem('darkMode', newDarkMode.toString());
    
    if (newDarkMode) {
      document.body.classList.add('dark-mode');
    } else {
      document.body.classList.remove('dark-mode');
    }
  };

  // Reset game state
  const resetGame = () => {
    setWord('');
    setHint('');
    setGuessedLetters([]);
    setWrongGuesses(0);
    setGameOver(false);
    setWon(false);
    setUsedHints([]);
    setRevealedLetters([]);
  };

  // Show temporary notification
  const showNotification = (message, type = 'success') => {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);

    setTimeout(() => {
      notification.classList.add('fade-out');
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 300);
    }, 2000);
  };

  // Add toggle function for sound
  const toggleSound = () => {
    const newSoundState = !soundEnabled;
    setSoundEnabled(newSoundState);
    localStorage.setItem('soundEnabled', newSoundState.toString());
    
    if (newSoundState) {
      preloadSounds();
    }
    
    showNotification(`Sound ${newSoundState ? 'enabled' : 'disabled'}`);
    
    // Play a test sound if enabled
    if (newSoundState) {
      setTimeout(() => playSound('click'), 300);
    }
  };

  // Update the play sound function to use preloaded audio elements
  const playSound = (soundType) => {
    if (!soundEnabled) return;
    
    console.log(`Attempting to play sound: ${soundType}`);
    
    try {
      // If audio element exists and is loaded
      if (audioElements[soundType]) {
        // Clone the audio to allow overlapping sounds
        const audioToPlay = audioElements[soundType].cloneNode();
        audioToPlay.volume = 0.5; // 50% volume
        
        const playPromise = audioToPlay.play();
        
        if (playPromise !== undefined) {
          playPromise.catch(error => {
            console.error(`Error playing sound ${soundType}:`, error);
            // Try fallback
            fallbackPlaySound(soundType);
          });
        }
      } else {
        // Fallback to creating a new audio element
        fallbackPlaySound(soundType);
      }
    } catch (error) {
      console.error(`Error in playSound for ${soundType}:`, error);
      fallbackPlaySound(soundType);
    }
  };

  // Add a fallback method for playing sounds
  const fallbackPlaySound = (soundType) => {
    console.log(`Using fallback for sound: ${soundType}`);
    const audioElement = new Audio();
    
    // Get the soundUrls reference
    const soundUrls = {
      correct: {
        url: "./audio/correct.mp3"
      },
      wrong: {
        url: "./audio/wrong.mp3"
      },
      win: {
        url: "./audio/win.mp3"
      },
      lose: {
        url: "./audio/lose.mp3"
      },
      click: {
        url: "./audio/click.mp3"
      },
      achievement: {
        url: "./audio/win.mp3" // Use win sound for achievements
      }
    };
    
    if (!soundUrls[soundType]) {
      console.error(`Unknown sound type: ${soundType}`);
      return;
    }

    // Try to load and play the file
    audioElement.src = soundUrls[soundType].url;
    audioElement.volume = 0.5; // 50% volume
    audioElement.play().catch(error => {
      console.error(`Error playing sound ${soundType}:`, error);
    });
  };

  // Add confetti effect
  const showConfetti = () => {
    // Create confetti container if it doesn't exist
    let confettiContainer = document.getElementById('confetti-container');
    
    if (!confettiContainer) {
      confettiContainer = document.createElement('div');
      confettiContainer.id = 'confetti-container';
      document.body.appendChild(confettiContainer);
    }
    
    // Clear previous confetti
    confettiContainer.innerHTML = '';
    
    // Generate confetti pieces
    for (let i = 0; i < 100; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * 100 + 'vw';
      confetti.style.animationDelay = Math.random() * 2 + 's';
      confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 80%, 60%)`;
      
      confettiContainer.appendChild(confetti);
    }
    
    // Remove confetti after animation ends
    setTimeout(() => {
      const container = document.getElementById('confetti-container');
      if (container) {
        container.innerHTML = '';
      }
    }, 5000);
  };

  // Function to eliminate some incorrect options
  const eliminateOptions = () => {
    if (score < HINT_COSTS.ELIMINATE_OPTIONS) {
      showNotification(`Need ${HINT_COSTS.ELIMINATE_OPTIONS} points to eliminate options`, 'error');
      return;
    }

    // Get unused letters
    const unusedLetters = alphabet.filter(letter => 
      !guessedLetters.includes(letter) && !word.toLowerCase().includes(letter)
    );
    
    if (unusedLetters.length < 3) {
      showNotification('Not enough options to eliminate!', 'info');
      return;
    }

    // Randomly select 3 incorrect letters to eliminate
    const lettersToEliminate = [];
    for (let i = 0; i < 3 && i < unusedLetters.length; i++) {
      const randomIndex = Math.floor(Math.random() * unusedLetters.length);
      lettersToEliminate.push(unusedLetters[randomIndex]);
      unusedLetters.splice(randomIndex, 1);
    }
    
    // Add them to guessed letters
    setGuessedLetters(prev => [...prev, ...lettersToEliminate]);
    
    // Deduct points
    setScore(prev => prev - HINT_COSTS.ELIMINATE_OPTIONS);
    setUsedHints(prev => [...prev, 'eliminate']);
    
    showNotification(`Eliminated ${lettersToEliminate.length} incorrect letters`, 'success');
    playSound('hint');
  };

  // Handle letter guess
  const handleGuess = (letter) => {
    if (gameOver || guessedLetters.includes(letter)) return;
    
    playSound('click');
    
    const newGuessedLetters = [...guessedLetters, letter];
    setGuessedLetters(newGuessedLetters);
    
    if (!word.toLowerCase().includes(letter.toLowerCase())) {
      playSound('wrong');
      const newWrongGuesses = wrongGuesses + 1;
      setWrongGuesses(newWrongGuesses);
      
      // Check if game is lost
      if (newWrongGuesses >= MAX_WRONG_GUESSES) {
        handleLoss();
        showNotification(`Game over! The word was "${word}"`, 'error');
        
        // Update user stats
        updateUserStats(false);
      }
    } else {
      playSound('correct');
      // Check if word is completely guessed
      const isWordGuessed = checkWinCondition(newGuessedLetters);
      
      if (isWordGuessed) {
        showNotification(`Congratulations! You earned ${POINTS_MAP[difficulty]} points!`);
        
        // Play win sound and show confetti
        showConfetti();
        
        // Update user stats
        updateUserStats(true);
      }
    }
  };
  
  // Check win condition helper
  const checkWinCondition = (guessedList) => {
    const isWordGuessed = word.toLowerCase().split('').every(char => 
      char === ' ' || guessedList.includes(char.toLowerCase()) || !alphabet.includes(char.toLowerCase())
    );
    
    if (isWordGuessed) {
      handleWin();
      return true;
    }
    return false;
  };
  
  // Fix revealLetter function
  const revealLetter = () => {
    if (score < HINT_COSTS.REVEAL_LETTER) {
      showNotification(`Need ${HINT_COSTS.REVEAL_LETTER} points to reveal a letter`, 'error');
      return;
    }

    // Find letters that are not yet guessed or revealed
    const unrevealedLetters = word.toLowerCase().split('')
      .filter(letter => 
        !guessedLetters.includes(letter) && 
        alphabet.includes(letter) && // Only include valid alphabet letters
        letter !== ' ' // Exclude spaces
      );
    
    if (unrevealedLetters.length === 0) {
      showNotification('All letters are already revealed!', 'info');
      return;
    }

    // Randomly select an unrevealed letter
    const letterToReveal = unrevealedLetters[Math.floor(Math.random() * unrevealedLetters.length)];
    
    // Add it to guessed letters and revealed letters
    const updatedGuessedLetters = [...guessedLetters, letterToReveal];
    setGuessedLetters(updatedGuessedLetters);
    setRevealedLetters(prev => [...prev, letterToReveal]);
    
    // Deduct points
    setScore(prev => prev - HINT_COSTS.REVEAL_LETTER);
    setUsedHints(prev => [...prev, 'reveal']);
    
    showNotification(`Revealed letter: ${letterToReveal.toUpperCase()}`, 'success');
    playSound('hint');
    
    // Check if word is completely guessed after revealing
    checkWinCondition(updatedGuessedLetters);
  };

  // Update user stats after game end
  const updateUserStats = (didWin) => {
    if (!currentUser) return;
    
    const updatedUser = {
      ...currentUser,
      score: didWin ? currentUser.score + POINTS_MAP[difficulty] : currentUser.score,
      totalGames: currentUser.totalGames + 1,
      wins: didWin ? (currentUser.wins || 0) + 1 : (currentUser.wins || 0),
      availableHints: currentUser.availableHints || 0
    };
    
    setCurrentUser(updatedUser);
    
    // Update in users array
    const updatedUsers = users.map(user => 
      user.username === currentUser.username ? updatedUser : user
    );
    
    setUsers(updatedUsers);
    localStorage.setItem('currentUser', JSON.stringify(updatedUser));
    
    // Fetch educational fact if won
    if (didWin) {
      setTimeout(() => {
        fetchEducationalFact();
      }, 1500); // Delay to allow win celebration first
      
      // Extra check for achievements
      setTimeout(() => {
        console.log("Checking achievements again from updateUserStats");
        checkAchievements(true, wrongGuesses === 0, winStreak + 1);
      }, 300);
    }
  };

  // Function to specifically update a user's score (for achievements and daily challenge)
  const updateUserScore = (username, pointsToAdd) => {
    if (!username) return;
    
    // Update current user if it's the same user
    if (currentUser && currentUser.username === username) {
      const updatedUser = {
        ...currentUser,
        score: currentUser.score + pointsToAdd
      };
      setCurrentUser(updatedUser);
      setScore(updatedUser.score);
      localStorage.setItem('currentUser', JSON.stringify(updatedUser));
    }
    
    // Update in users array
    const updatedUsers = users.map(user => {
      if (user.username === username) {
        return {
          ...user,
          score: user.score + pointsToAdd
        };
      }
      return user;
    });
    
    setUsers(updatedUsers);
    localStorage.setItem('users', JSON.stringify(updatedUsers));
  };

  // Generate a new word to guess
  const generateWord = async () => {
    if (!apiKey || apiKey === "YOUR_GEMINI_API_KEY") {
      showNotification('Please add your API key in the App.js file', 'error');
      return;
    }

    try {
      setLoading(true);
      resetGame();

      // Get topic based on selection
      let topicToUse;
      if (selectedTopic === 'random') {
        // Get a random disaster topic
        topicToUse = disasterTopics[Math.floor(Math.random() * disasterTopics.length)];
      } else {
        topicToUse = selectedTopic;
      }
      
      // Adjust word difficulty
      let complexityLevel = "moderate";
      let wordLength = "4-12";
      
      if (difficulty === 'easy') {
        complexityLevel = "simple";
        wordLength = "4-6";
      } else if (difficulty === 'hard') {
        complexityLevel = "challenging";
        wordLength = "8-12";
      }

      // Add previously used words to the prompt
      const usedWordsString = usedWords.length > 0 
        ? `Avoid these previously used words: ${usedWords.join(', ')}. ` 
        : '';

      const prompt = `Generate a single disaster preparedness related term about ${topicToUse} for a word guessing game. 
${usedWordsString}The word should be ${complexityLevel} in complexity and ${wordLength} letters long.
Format your response EXACTLY as follows with no additional text:
{
  "word": "a single word or short phrase related to disaster preparedness",
  "hint": "a brief hint about the word or phrase to help the player guess"
}`;

      const result = await fetchGeminiResponse(apiKey, prompt, 'gemini-1.5-flash');
      
      try {
        // Clean the result if it contains code block formatting
        let cleanedResult = result;
        
        // Check if the result is wrapped in code blocks and extract just the JSON content
        if (result.includes('```json')) {
          cleanedResult = result.replace(/```json\n|\n```/g, '');
        } else if (result.includes('```')) {
          cleanedResult = result.replace(/```\n|\n```/g, '');
        }
        
        const parsedResult = JSON.parse(cleanedResult);
        
        // Check if word has been used before
        if (usedWords.includes(parsedResult.word.toLowerCase())) {
          // Try again if the word has been used before (up to 3 attempts)
          if (retryCount < 3) {
            retryCount++;
            await generateWord();
            return;
          } else {
            // Reset retry counter and proceed with the word anyway
            retryCount = 0;
            showNotification('Note: You may see a repeated word due to limited options', 'info');
          }
        } else {
          // Add the new word to the used words list
          setUsedWords(prev => {
            // Keep only the last 50 words to avoid making the prompt too long
            const updatedWords = [...prev, parsedResult.word.toLowerCase()];
            if (updatedWords.length > 50) {
              return updatedWords.slice(updatedWords.length - 50);
            }
            return updatedWords;
          });
        }
        
        setWord(parsedResult.word);
        setHint(parsedResult.hint);
        setTotalGames(prevTotal => prevTotal + 1);
    } catch (error) {
        showNotification('Failed to parse response. Please try again.', 'error');
        console.error('Failed to parse result:', result);
      }
    } catch (error) {
      showNotification(`Error: ${error.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  // Add a retry counter variable outside the function scope
  let retryCount = 0;
  
  // Start a new game
  const handleNewGame = () => {
    generateWord();
  };

  // Get the current masked word display
  const getMaskedWord = () => {
    if (!word) return '';
    
    return word.split('').map(char => {
      if (char === ' ') return ' ';
      if (!alphabet.includes(char.toLowerCase())) return char;
      return guessedLetters.includes(char.toLowerCase()) ? char : '_';
    }).join(' ');
  };

  // Function to call Gemini API
  const fetchGeminiResponse = async (apiKey, prompt, model) => {
    const apiUrl = `https://generativelanguage.googleapis.com/v1/models/${model}:generateContent?key=${apiKey}`;
    
    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: prompt
            }
          ]
        }
      ]
    };

    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error?.message || 'Failed to get response from Gemini API');
    }

    const data = await response.json();
    
    try {
      return data.candidates[0].content.parts[0].text;
    } catch (e) {
      console.error('Unexpected response format:', data);
      return JSON.stringify(data, null, 2);
    }
  };

  // Calculate progress percentage
  const getProgressPercentage = () => {
    return (wrongGuesses / MAX_WRONG_GUESSES) * 100;
  };
  
  // Login handler
  const handleLogin = (e) => {
    e.preventDefault();
    
    if (!username.trim() || !password.trim()) {
      showNotification('Please enter both username and password', 'error');
      return;
    }
    
    // Check if user exists
    const existingUser = users.find(user => user.username === username);
    
    if (existingUser) {
      // Check password
      if (existingUser.password === password) {
        setCurrentUser(existingUser);
        setScore(existingUser.score || 0);
        setTotalGames(existingUser.totalGames || 0);
        setIsLoggedIn(true);
        showNotification(`Welcome back, ${existingUser.username}!`);
        localStorage.setItem('currentUser', JSON.stringify(existingUser));
        
        // Start background music if enabled
        if (musicEnabled && !backgroundMusic) {
          initBackgroundMusic(currentTrack, musicVolume);
        }
      } else {
        showNotification('Incorrect password', 'error');
      }
    } else {
      // Register new user
      const newUser = {
        username,
        password,
        score: 0,
        totalGames: 0,
        wins: 0,
        registerDate: new Date().toISOString()
      };
      
      setUsers([...users, newUser]);
      setCurrentUser(newUser);
      setScore(0);
      setTotalGames(0);
      setIsLoggedIn(true);
      showNotification(`Welcome, ${username}! Account created.`);
      localStorage.setItem('currentUser', JSON.stringify(newUser));
      
      // Start background music if enabled
      if (musicEnabled && !backgroundMusic) {
        initBackgroundMusic(currentTrack, musicVolume);
      }
    }
    
    // Clear form
    setUsername('');
    setPassword('');
  };
  
  // Logout handler
  const handleLogout = () => {
    setIsLoggedIn(false);
    setCurrentUser(null);
    setScore(0);
    setTotalGames(0);
    resetGame();
    localStorage.removeItem('currentUser');
    showNotification('Logged out successfully');
  };
  
  // Change difficulty
  const handleChangeDifficulty = (newDifficulty) => {
    setDifficulty(newDifficulty);
    resetGame();
  };
  
  // Toggle leaderboard
  const toggleLeaderboard = () => {
    setShowLeaderboard(!showLeaderboard);
  };
  
  // Sort users by score (for leaderboard)
  const getSortedUsers = () => {
    return [...users].sort((a, b) => b.score - a.score).slice(0, 10); // Top 10 users
  };

  // Function to render the scoreboard
  const renderScoreboard = () => {
    const topUsers = getSortedUsers();
  return (
      <div className="scoreboard">
        <h3>Top Players</h3>
        <div className="scoreboard-list">
          {topUsers.length === 0 ? (
            <p>No scores yet!</p>
          ) : (
            topUsers.map((user, index) => (
              <div key={index} className="scoreboard-item">
                <span className="rank">{index + 1}.</span>
                <span className="username">{user.username}</span>
                <span className="score">{user.score}</span>
              </div>
            ))
          )}
        </div>
      </div>
    );
  };

  // Add toggle function for topic selector
  const toggleTopicSelector = () => {
    setShowTopicSelector(!showTopicSelector);
  };

  // Add function to handle topic selection
  const handleTopicSelect = (topic) => {
    setSelectedTopic(topic);
    setShowTopicSelector(false);
    showNotification(`Topic set to: ${topic}`);
  };

  // Add new function for purchasing hints
  const purchaseHint = (hintType) => {
    // This is a stub function - will be implemented later 
  };

  // Add a preload sounds function
  const preloadSounds = () => {
    console.log("Preloading sound effects...");

    const soundUrls = {
      correct: {
        url: "./audio/correct.mp3"
      },
      wrong: {
        url: "./audio/wrong.mp3"
      },
      win: {
        url: "./audio/win.mp3"
      },
      lose: {
        url: "./audio/lose.mp3"
      },
      click: {
        url: "./audio/click.mp3"
      },
      achievement: {
        url: "./audio/win.mp3" // Use win sound for achievements since they don't have their own
      }
    };

    // Create and preload audio elements
    Object.keys(soundUrls).forEach(soundType => {
      try {
        audioElements[soundType] = new Audio();
        
        // Try to load the local file
        audioElements[soundType].src = soundUrls[soundType].url;
        audioElements[soundType].load();
        
        // Add a test to make sure the audio can be played
        audioElements[soundType].addEventListener('canplaythrough', () => {
          console.log(`Sound ${soundType} loaded successfully`);
        });
        
        console.log(`Preloading sound: ${soundType} from ${soundUrls[soundType].url}`);
      } catch (error) {
        console.error(`Error preloading sound ${soundType}:`, error);
      }
    });
  };

  // Add function to initialize background music
  const initBackgroundMusic = (trackIndex = 0, volume = 0.5) => {
    console.log(`Initializing background music with volume: ${volume}`);
    
    // If there's already music playing, stop it
    if (backgroundMusic) {
      backgroundMusic.pause();
      backgroundMusic.src = '';
    }
    
    // Create new audio element for music
    const music = new Audio();
    music.volume = volume;
    music.loop = true;
    
    // Get the current track
    const track = musicTracks[trackIndex];
    
    console.log('Loading music from:', track.url);
    music.src = track.url;
    music.load();
    
    // Attempt to play the music immediately
    try {
      const playPromise = music.play();
      
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            console.log('Music started successfully');
          })
          .catch(error => {
            console.error('Autoplay prevented by browser:', error);
            
            // Fallback for browsers that block autoplay
            const clickHandler = () => {
              if (musicEnabled) {
                music.play().catch(e => console.error('Error playing music on click:', e));
              }
              document.removeEventListener('click', clickHandler);
            };
            
            document.addEventListener('click', clickHandler);
          });
      }
    } catch (error) {
      console.error('Error trying to play music:', error);
    }
    
    // When music ends, play it again (as a fallback if loop doesn't work)
    music.addEventListener('ended', () => {
      if (musicEnabled) {
        music.currentTime = 0;
        music.play().catch(error => console.error('Error replaying music:', error));
      }
    });
    
    setBackgroundMusic(music);
    
    // Return the music object for potential further handling
    return music;
  };
  
  // Update the toggleMusic function 
  const toggleMusic = () => {
    const newMusicState = !musicEnabled;
    setMusicEnabled(newMusicState);
    localStorage.setItem('musicEnabled', newMusicState.toString());
    localStorage.setItem('musicVolume', '0.5'); // Set to 50% volume
    
    console.log(`Music toggled to: ${newMusicState ? 'enabled' : 'disabled'}`);
    
    if (newMusicState) {
      // When enabling music
      console.log("Enabling music");
      
      // First check if we already have a backgroundMusic element
      if (backgroundMusic && !backgroundMusic.paused) {
        console.log("Background music already exists and is playing");
        showNotification('Music is already playing', 'info');
        return;
      }
      
      if (backgroundMusic && backgroundMusic.paused) {
        // Try to resume existing music element
        console.log("Trying to resume paused music");
        try {
          const playPromise = backgroundMusic.play();
          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                console.log('Resumed existing music successfully');
                showNotification('Music resumed', 'info');
              })
              .catch(error => {
                console.error('Error resuming music:', error);
                // If resume fails, try reinitializing
                console.log("Resume failed, reinitializing...");
                initBackgroundMusic(currentTrack, musicVolume);
              });
          }
        } catch (error) {
          console.error("Error trying to resume music:", error);
          // Fall back to initializing new music
          initBackgroundMusic(currentTrack, musicVolume);
        }
      } else {
        // No existing music, initialize new
        console.log("No existing music, initializing new");
        initBackgroundMusic(currentTrack, musicVolume);
      }
    } else {
      // When disabling music
      console.log("Disabling music");
      if (backgroundMusic) {
        console.log("Pausing background music");
        try {
          backgroundMusic.pause();
          console.log("Music paused successfully");
        } catch (error) {
          console.error("Error pausing music:", error);
        }
      } else {
        console.log("No background music to pause");
      }
      showNotification('Music disabled', 'info');
    }
  };

  // Add function to adjust music volume
  const adjustVolume = (newVolume) => {
    // Set to 50% volume
    const volume = 0.5;
    
    setMusicVolume(volume);
    localStorage.setItem('musicVolume', volume.toString());
    
    if (backgroundMusic) {
      backgroundMusic.volume = volume;
    }
  };

  // Add a cancelGame function
  const cancelGame = () => {
    resetGame();
    showNotification('Game cancelled');
    playSound('click');
  };

  // Add a function to clear the word history (for testing or to reset when needed)
  const clearWordHistory = () => {
    setUsedWords([]);
    localStorage.removeItem('usedWords');
    showNotification('Word history cleared', 'success');
  };

  // Function to award an achievement
  const awardAchievement = (achievementId) => {
    // Check if the achievement ID exists in the ACHIEVEMENTS object
    if (!ACHIEVEMENTS[achievementId] && !Object.values(ACHIEVEMENTS).find(a => a.id === achievementId)) {
      console.error(`Achievement ID not found: ${achievementId}`);
      return false;
    }
    
    // Find the achievement by ID or key
    const achievement = ACHIEVEMENTS[achievementId] || Object.values(ACHIEVEMENTS).find(a => a.id === achievementId);
    
    // Check if user has this achievement already
    if (!currentUser || 
        !achievements[currentUser.username] || 
        achievements[currentUser.username].includes(achievement.id)) {
      return false;
    }
    
    // Award the achievement
    const newAchievements = {
      ...achievements,
      [currentUser.username]: [
        ...(achievements[currentUser.username] || []),
        achievement.id
      ]
    };
    
    setAchievements(newAchievements);
    
    // Award points
    const pointsToAward = achievement.points || 0;
    
    if (pointsToAward > 0) {
      updateUserScore(currentUser.username, pointsToAward);
      showNotification(`Achievement Unlocked: ${achievement.title} (+${pointsToAward} points)`, 'achievement');
    } else {
      showNotification(`Achievement Unlocked: ${achievement.title}`, 'achievement');
    }
    
    playSound('achievement');
    return true;
  };
  
  // Function to check achievements after a game
  const checkAchievements = (gameWon, noWrongGuesses, currentStreak) => {
    if (!currentUser) return;
    
    // Initialize achievements for user if they don't exist
    if (!achievements[currentUser.username]) {
      setAchievements({
        ...achievements,
        [currentUser.username]: []
      });
    }
    
    // Get user's current achievements
    const userAchievements = achievements[currentUser.username] || [];
    
    // Check for first win
    if (gameWon && !userAchievements.includes(ACHIEVEMENTS.FIRST_WIN.id)) {
      awardAchievement(ACHIEVEMENTS.FIRST_WIN.id);
    }
    
    // Check for perfect game
    if (gameWon && noWrongGuesses && !userAchievements.includes(ACHIEVEMENTS.PERFECT_GAME.id)) {
      awardAchievement(ACHIEVEMENTS.PERFECT_GAME.id);
    }
    
    // Check for 3 win streak
    if (gameWon && currentStreak >= 3 && !userAchievements.includes(ACHIEVEMENTS.STREAK_3.id)) {
      awardAchievement(ACHIEVEMENTS.STREAK_3.id);
    }
    
    // Check for hint master
    if (gameWon && 
        usedHints.includes('reveal') && 
        usedHints.includes('eliminate') && 
        !userAchievements.includes(ACHIEVEMENTS.HINT_MASTER.id)) {
      awardAchievement(ACHIEVEMENTS.HINT_MASTER.id);
    }
    
    // Check for hard mode win
    if (gameWon && 
        difficulty === 'hard' && 
        !userAchievements.includes(ACHIEVEMENTS.HARD_MODE.id)) {
      awardAchievement(ACHIEVEMENTS.HARD_MODE.id);
    }
  };
  
  // Add a state for tracking win streak
  const [winStreak, setWinStreak] = useState(0);

  // Update handle win to check for daily puzzle
  const handleWin = () => {
    setGameOver(true);
    setWon(true);
    playSound('win');
    
    // Update user score with regular points
    const pointsEarned = POINTS_MAP[difficulty];
    updateUserScore(currentUser.username, pointsEarned);
    
    // Update win streak
    const newWinStreak = winStreak + 1;
    setWinStreak(newWinStreak);
    
    // Check achievements - after state is updated
    setTimeout(() => {
      checkAchievements(true, wrongGuesses === 0, newWinStreak);
    }, 100);
  };

  // Handle a loss
  const handleLoss = () => {
    setGameOver(true);
    setWon(false);
    playSound('lose');
    
    // Reset win streak on loss
    setWinStreak(0);
  };

  // Function to fetch educational fact about the word
  const fetchEducationalFact = async () => {
    if (!apiKey || !word) return;
    
    try {
      setLoading(true);
      
      const prompt = `Provide a brief educational paragraph (2-3 sentences) about "${word}" in the context of disaster preparedness. 
Make it informative and factual. Keep it concise and educational.`;

      const result = await fetchGeminiResponse(apiKey, prompt, 'gemini-1.5-flash');
      setFactContent(result);
      setShowFactModal(true);
    } catch (error) {
      console.error('Error fetching educational content:', error);
    } finally {
      setLoading(false);
    }
  };

  // Function to debug and reset achievements
  const debugAchievements = () => {
    if (!currentUser) return;
    
    console.log('Current achievements:', achievements);
    console.log('User achievements:', achievements[currentUser.username]);
    
    // Clear achievements for current user
    const resetAchievements = {
      ...achievements,
      [currentUser.username]: []
    };
    
    setAchievements(resetAchievements);
    localStorage.setItem('achievements', JSON.stringify(resetAchievements));
    console.log('Achievements reset for user:', currentUser.username);
    showNotification('Achievements reset', 'info');
  };

  // UI Rendering
  return (
    <div className={`App ${darkMode ? 'dark-mode' : ''}`}>
      <div className="container">
        <header>
          <h1>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
              <path d="M2 17l10 5 10-5"></path>
              <path d="M2 12l10 5 10-5"></path>
            </svg>
            Disaster Preparedness Word Game
          </h1>
          <div className="header-controls">
            {isLoggedIn && (
              <div className="user-controls">
                <div className="score-display">
                  Score: {score}/{totalGames}
                </div>
                
                <button onClick={() => setShowAchievements(true)} className="achievements-btn" title="Achievements">
                  ðŸ†
                </button>
              </div>
            )}
            
            <button onClick={toggleSound} className="theme-toggle" aria-label="Toggle sound">
              {soundEnabled ? (
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                  <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                  <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
                </svg>
              ) : (
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                  <line x1="23" y1="9" x2="17" y2="15"></line>
                  <line x1="17" y1="9" x2="23" y2="15"></line>
                </svg>
              )}
            </button>
            
            <button onClick={toggleMusic} className="theme-toggle" aria-label="Toggle music">
              {musicEnabled ? (
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M9 18V5l12-2v13"></path>
                  <circle cx="6" cy="18" r="3"></circle>
                  <circle cx="18" cy="16" r="3"></circle>
                </svg>
              ) : (
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M9 18V5l12-2v13"></path>
                  <circle cx="6" cy="18" r="3"></circle>
                  <circle cx="18" cy="16" r="3"></circle>
                  <line x1="3" y1="3" x2="21" y2="21"></line>
                </svg>
              )}
            </button>
            
            <button onClick={toggleDarkMode} className="theme-toggle" aria-label="Toggle dark mode">
              {darkMode ? (
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <circle cx="12" cy="12" r="5"></circle>
                  <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"></path>
                </svg>
              ) : (
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
              )}
            </button>
          </div>
        </header>
        
        <div className="main-layout">
          <div className="game-section">
            {!isLoggedIn ? (
              // Login Form
              <div className="login-container">
                <h2>Login / Register</h2>
                <form onSubmit={handleLogin} className="login-form">
                  <div className="form-group">
                    <label htmlFor="username">Username</label>
            <input 
                      type="text" 
                      id="username" 
                      value={username} 
                      onChange={(e) => setUsername(e.target.value)}
                      placeholder="Enter username"
                      required
                    />
          </div>
                  <div className="form-group">
                    <label htmlFor="password">Password</label>
                    <input 
                      type="password" 
                      id="password" 
                      value={password} 
                      onChange={(e) => setPassword(e.target.value)}
                      placeholder="Enter password"
                      required
                    />
                  </div>
                  <button type="submit" className="login-btn">Login / Register</button>
                </form>
              </div>
            ) : (
              <div className="game-container">
                {loading ? (
                  <div className="loading">Loading...</div>
                ) : !word ? (
                  <div className="start-game">
                    <h2>Welcome, {currentUser?.username}!</h2>
                    
                    <div className="difficulty-selector">
                      <span>Difficulty: </span>
                      <button 
                        className={`difficulty-btn ${difficulty === 'easy' ? 'active' : ''}`}
                        onClick={() => handleChangeDifficulty('easy')}
                      >
                        Easy
                      </button>
                      <button 
                        className={`difficulty-btn ${difficulty === 'medium' ? 'active' : ''}`}
                        onClick={() => handleChangeDifficulty('medium')}
                      >
                        Medium
                      </button>
                      <button 
                        className={`difficulty-btn ${difficulty === 'hard' ? 'active' : ''}`}
                        onClick={() => handleChangeDifficulty('hard')}
                      >
                        Hard
                      </button>
            </div>
                    <button onClick={handleNewGame} className="start-btn">Start Game</button>
                    <button onClick={handleLogout} className="logout-btn">Logout</button>
          </div>
                ) : (
                  <div className="game-area">
                    <div className="game-header">
                      <button onClick={cancelGame} className="back-btn">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <path d="M19 12H5M12 19l-7-7 7-7"></path>
                        </svg>
                        Back
                      </button>
                      <div className="difficulty-display">
                        <span className="difficulty-label">Difficulty:</span> 
                        <span className="difficulty-value">{difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}</span>
                      </div>
        </div>
                    
                    <div className="word-area">
                      <div className="hint">Hint: {hint}</div>
                      <div className="word">{getMaskedWord()}</div>
                      <div className="guess-tracker">
                        <div className="attempts-label">Attempts Remaining: <span className="attempts-number">{MAX_WRONG_GUESSES - wrongGuesses}</span></div>
                        <div className="progress-bar-container">
                          <div 
                            className="progress-bar" 
                            style={{width: `${getProgressPercentage()}%`}}
                          ></div>
        </div>
      </div>
                      
                      {/* Hint System UI */}
                      {!gameOver && (
                        <div className="hint-system">
                          <div className="hint-buttons">
                            <button 
                              onClick={revealLetter} 
                              className={`hint-btn ${score < HINT_COSTS.REVEAL_LETTER ? 'disabled' : ''}`}
                              disabled={score < HINT_COSTS.REVEAL_LETTER || gameOver}
                              title={`Costs ${HINT_COSTS.REVEAL_LETTER} points`}
                            >
                              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                              </svg>
                              Reveal Letter ({HINT_COSTS.REVEAL_LETTER} pts)
                            </button>
                            
                            <button 
                              onClick={eliminateOptions} 
                              className={`hint-btn ${score < HINT_COSTS.ELIMINATE_OPTIONS ? 'disabled' : ''}`}
                              disabled={score < HINT_COSTS.ELIMINATE_OPTIONS || gameOver}
                              title={`Costs ${HINT_COSTS.ELIMINATE_OPTIONS} points`}
                            >
                              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <path d="M3 3l18 18M10.5 10.677a2 2 0 002.823 2.823"></path>
                                <path d="M7.362 7.561C5.68 8.74 4.279 10.42 3 12c1.889 2.991 5.282 6 9 6 1.55 0 3.043-.523 4.395-1.35M12 6c4.008 0 6.701 3.158 9 6a15.66 15.66 0 01-1.078 1.5"></path>
                              </svg>
                              Eliminate 3 Letters ({HINT_COSTS.ELIMINATE_OPTIONS} pts)
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                    
                    <div className="keyboard">
                      {alphabet.map(letter => (
                        <button 
                          key={letter} 
                          className={`keyboard-key 
                            ${guessedLetters.includes(letter) ? 'guessed' : ''} 
                            ${guessedLetters.includes(letter) && !word.toLowerCase().includes(letter) ? 'wrong' : ''}
                            ${guessedLetters.includes(letter) && word.toLowerCase().includes(letter) ? 'correct' : ''}
                          `}
                          onClick={() => handleGuess(letter)}
                          disabled={gameOver || guessedLetters.includes(letter)}
                        >
                          {letter}
                        </button>
                      ))}
                    </div>
                    
                    {gameOver && (
                      <div className="game-result">
                        {won ? (
                          <div className="result-message win">
                            <div>Congratulations! You won!</div>
                            <div>You earned {POINTS_MAP[difficulty]} points</div>
                          </div>
                        ) : (
                          <div className="result-message lose">
                            <div>Game Over!</div>
                            <div>The word was: <span className="revealed-word">{word}</span></div>
                          </div>
                        )}
                        <button onClick={handleNewGame} className="new-game-btn">
                          New Game
                        </button>
                      </div>
                    )}
                  </div>
                )}
              </div>
            )}
          </div>
          
          {/* Scoreboard - Always visible */}
          <div className="scoreboard">
            <h2>Top Players</h2>
            {getSortedUsers().length > 0 ? (
              <div className="scoreboard-list">
                {getSortedUsers().map((user, index) => (
                  <div key={index} className="scoreboard-item">
                    <span className="rank">{index + 1}</span>
                    <span className="username">{user.username}</span>
                    <span className="score">{user.score}</span>
                  </div>
                ))}
              </div>
            ) : (
              <p>No scores yet!</p>
            )}
          </div>
        </div>
        
        <footer>
          <div>Disaster Preparedness Word Game</div>
        </footer>
      </div>
      
      {/* Add this CSS style block */}
      <style>{`
        /* Base styles and layout */
        .main-layout {
          display: flex;
          gap: 20px;
          margin-bottom: 20px;
        }
        
        .game-section {
          flex: 3;
        }
        
        /* Card styling improvements */
        .game-area, .login-container, .start-game, .scoreboard {
          background-color: var(--card-bg-color, #f5f5f5);
          border-radius: 12px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          padding: 20px;
          transition: all 0.3s ease;
        }
        
        /* Game header improvements */
        .game-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 20px;
        }
        
        .back-btn {
          display: flex;
          align-items: center;
          gap: 5px;
          padding: 8px 12px;
          background-color: var(--card-inner-bg, white);
          color: var(--text-color, #333);
          border: 1px solid var(--border-color, #ddd);
          border-radius: 6px;
          cursor: pointer;
          font-weight: 500;
          transition: all 0.2s;
        }
        
        .back-btn:hover {
          background-color: var(--primary-color, #4285f4);
          color: white;
          transform: translateX(-2px);
        }
        
        .difficulty-display {
          font-weight: 600;
          padding: 8px 15px;
          background-color: var(--primary-color, #4285f4);
          color: white;
          border-radius: 6px;
          border: 1px solid var(--border-color, #ddd);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          font-size: 1rem;
          display: flex;
          align-items: center;
          gap: 8px;
        }
        
        .difficulty-label {
          font-weight: 500;
        }
        
        .difficulty-value {
          font-weight: 700;
          letter-spacing: 0.5px;
        }
        
        .dark-mode .difficulty-display {
          background-color: var(--primary-color, #6fa4f5);
          border-color: #444;
        }
        
        /* Login form improvements */
        .login-container {
          max-width: 480px;
          margin: 0 auto;
          padding: 30px;
          text-align: center;
        }
        
        .login-container h2 {
          margin-bottom: 25px;
          color: var(--primary-color, #4285f4);
          font-size: 28px;
        }
        
        .login-form {
          max-width: 400px;
          margin: 0 auto;
          background-color: var(--card-inner-bg, white);
          padding: 25px;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        .form-group {
          margin-bottom: 22px;
          text-align: left;
        }
        
        .form-group label {
          display: block;
          margin-bottom: 8px;
          font-weight: 500;
          color: var(--text-color, #333);
        }
        
        .form-group input {
          width: 100%;
          padding: 12px 15px;
          border: 1px solid var(--border-color, #ddd);
          border-radius: 6px;
          font-size: 16px;
          background-color: var(--input-bg-color, #fff);
          color: var(--text-color, #333);
          transition: all 0.2s;
        }
        
        .form-group input:focus {
          border-color: var(--primary-color, #4285f4);
          outline: none;
          box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.2);
        }
        
        /* Button styling improvements */
        .login-btn, .start-btn, .logout-btn, .new-game-btn, .close-modal {
          padding: 12px 24px;
          border: none;
          border-radius: 6px;
          font-size: 16px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .login-btn, .start-btn {
          background-color: var(--primary-color, #4285f4);
          color: white;
          width: 100%;
        }
        
        .login-btn:hover, .start-btn:hover {
          background-color: var(--primary-color-dark, #3367d6);
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .logout-btn {
          background-color: #f5f5f5;
          color: #666;
          margin-top: 10px;
        }
        
        .difficulty-btn {
          padding: 8px 16px;
          border: 1px solid var(--border-color, #ddd);
          background-color: var(--card-inner-bg, white);
          border-radius: 6px;
          margin: 0 5px;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .difficulty-btn.active {
          background-color: var(--primary-color, #4285f4);
          color: white;
          border-color: var(--primary-color, #4285f4);
        }
        
        /* Improved word display */
        .word {
          font-size: 2.5rem;
          font-weight: 700;
          letter-spacing: 8px;
          margin: 25px 0;
          color: var(--text-color, #333);
          min-height: 60px;
        }
        
        .hint {
          font-size: 1.1rem;
          color: var(--text-secondary-color, #666);
          margin-bottom: 15px;
          font-style: italic;
        }
        
        /* Better keyboard styling */
        .keyboard {
          display: flex;
          flex-wrap: wrap;
          justify-content: center;
          gap: 8px;
          margin-top: 30px;
        }
        
        .keyboard-key {
          width: 42px;
          height: 42px;
          display: flex;
          align-items: center;
          justify-content: center;
          border: 2px solid var(--border-color, #ddd);
          border-radius: 6px;
          background-color: var(--card-inner-bg, white);
          color: var(--text-color, #333);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          font-size: 18px;
          font-weight: 700;
          text-transform: uppercase;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .keyboard-key:not(:disabled):hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
          background-color: var(--primary-color, #4285f4);
          color: white;
          border-color: var(--primary-color, #4285f4);
        }
        
        .keyboard-key.guessed {
          opacity: 0.7;
        }
        
        .keyboard-key.correct {
          background-color: #4caf50;
          color: white;
          border-color: #4caf50;
        }
        
        .keyboard-key.wrong {
          background-color: #f44336;
          color: white;
          border-color: #f44336;
        }
        
        /* Dark mode improvements for keyboard keys */
        .dark-mode .keyboard-key {
          background-color: #2c2c2c;
          color: #e0e0e0;
          border-color: #444;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .dark-mode .keyboard-key:not(:disabled):hover {
          background-color: var(--primary-color, #6fa4f5);
          border-color: var(--primary-color, #6fa4f5);
          color: white;
        }
        
        .dark-mode .keyboard-key.correct {
          background-color: #43a047;
          border-color: #43a047;
        }
        
        .dark-mode .keyboard-key.wrong {
          background-color: #e53935;
          border-color: #e53935;
        }
        
        /* Improved progress bar */
        .guess-tracker {
          margin: 20px 0;
        }
        
        .attempts-label {
          margin-bottom: 8px;
          font-weight: 500;
        }
        
        .attempts-number {
          font-weight: 700;
          color: var(--primary-color, #4285f4);
        }
        
        .progress-bar-container {
          height: 12px;
          background-color: #e0e0e0;
          border-radius: 6px;
          overflow: hidden;
          margin-top: 8px;
        }
        
        .progress-bar {
          height: 100%;
          background-color: #f44336;
          transition: width 0.3s ease;
        }
        
        /* Enhanced hint system */
        .hint-system {
          margin-top: 20px;
          padding-top: 15px;
          border-top: 1px solid var(--border-color, #ddd);
        }
        
        .hint-buttons {
          display: flex;
          gap: 15px;
          justify-content: center;
        }
        
        .hint-btn {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 10px 16px;
          background-color: var(--secondary-color, #ff9800);
          color: white;
          border: none;
          border-radius: 6px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .hint-btn:not(.disabled):hover {
          background-color: var(--secondary-color-dark, #f57c00);
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .hint-btn.disabled {
          background-color: #bdbdbd;
          cursor: not-allowed;
        }
        
        /* Better header styling */
        header {
          padding: 15px 0;
          margin-bottom: 30px;
          border-bottom: 1px solid var(--border-color, #ddd);
        }
        
        header h1 {
          display: flex;
          align-items: center;
          gap: 10px;
          font-size: 1.8rem;
          margin: 0;
        }
        
        .header-controls {
          display: flex;
          align-items: center;
          gap: 15px;
        }
        
        .theme-toggle {
          background: transparent;
          border: none;
          padding: 8px;
          border-radius: 50%;
          cursor: pointer;
          color: var(--text-color, #333);
          transition: all 0.2s;
          background-color: var(--card-inner-bg, white);
          border: 1px solid var(--border-color, #ddd);
          width: 36px;
          height: 36px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .theme-toggle:hover {
          background-color: var(--primary-color, #4285f4);
          color: white;
          transform: translateY(-2px);
        }
        
        .user-controls {
          display: flex;
          align-items: center;
          gap: 15px;
        }
        
        .score-display {
          font-weight: 500;
        }
        
        .achievements-btn {
          display: flex;
          align-items: center;
          justify-content: center;
          background-color: var(--card-inner-bg, white);
          color: var(--text-color, #333);
          border: 1px solid var(--border-color, #ddd);
          width: 36px;
          height: 36px;
          border-radius: 50%;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .achievements-btn:hover {
          background-color: var(--primary-color, #4285f4);
          color: white;
          transform: translateY(-2px);
        }
        
        /* Improved scoreboard */
        .scoreboard {
          flex: 1;
          background-color: var(--card-bg-color, #f5f5f5);
          padding: 20px;
          border-radius: 12px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          min-width: 200px;
          max-width: 300px;
          align-self: flex-start;
        }
        
        .scoreboard h2 {
          margin-top: 0;
          padding-bottom: 15px;
          margin-bottom: 15px;
          border-bottom: 2px solid var(--border-color, #ddd);
          color: var(--text-color, #333);
          font-size: 1.5rem;
          text-align: center;
        }
        
        .scoreboard-list {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        
        .scoreboard-item {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 12px;
          background-color: var(--card-inner-bg, white);
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
          transition: transform 0.2s;
        }
        
        .scoreboard-item:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .scoreboard-item:nth-child(1) {
          background: linear-gradient(135deg, #ffd700, #f9ce00);
          color: #000;
          font-weight: bold;
        }
        
        .scoreboard-item:nth-child(2) {
          background: linear-gradient(135deg, #c0c0c0, #b0b0b0);
          color: #000;
        }
        
        .scoreboard-item:nth-child(3) {
          background: linear-gradient(135deg, #cd7f32, #be7430);
          color: #000;
        }
        
        .rank {
          font-weight: bold;
          width: 25px;
        }
        
        .username {
          flex: 1;
          text-align: left;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
          padding: 0 5px;
        }
        
        .score {
          font-weight: bold;
        }
        
        /* Game result area */
        .game-result {
          margin-top: 30px;
          padding: 20px;
          border-radius: 8px;
          text-align: center;
        }
        
        .result-message {
          margin-bottom: 20px;
          font-size: 1.2rem;
        }
        
        .result-message.win {
          color: #4caf50;
        }
        
        .result-message.lose {
          color: #f44336;
        }
        
        .revealed-word {
          font-weight: bold;
          font-size: 1.3rem;
        }
        
        /* Modal improvements */
        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000;
          backdrop-filter: blur(3px);
        }
        
        .modal {
          background-color: var(--bg-color, white);
          border-radius: 12px;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
          padding: 25px;
          width: 90%;
          max-width: 500px;
          max-height: 80vh;
          overflow-y: auto;
          position: relative;
          animation: modalFadeIn 0.3s ease;
        }
        
        @keyframes modalFadeIn {
          from {
            opacity: 0;
            transform: translateY(10px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
        
        .achievements-modal h2 {
          text-align: center;
          margin-top: 0;
          margin-bottom: 25px;
          padding-bottom: 15px;
          border-bottom: 1px solid var(--border-color, #ddd);
          font-size: 1.8rem;
        }
        
        .achievements-list {
          display: flex;
          flex-direction: column;
          gap: 15px;
          margin-bottom: 25px;
        }
        
        .achievement-item {
          display: flex;
          align-items: center;
          padding: 15px;
          border-radius: 8px;
          background-color: var(--card-bg-color, #f5f5f5);
          transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .achievement-item:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .achievement-item.unlocked {
          border: 2px solid #4caf50;
        }
        
        .achievement-item.locked {
          opacity: 0.7;
          filter: grayscale(0.8);
        }
        
        .achievement-icon {
          font-size: 28px;
          margin-right: 15px;
          background-color: var(--card-inner-bg, white);
          width: 50px;
          height: 50px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .achievement-details {
          flex: 1;
        }
        
        .achievement-title {
          font-weight: bold;
          margin-bottom: 5px;
          font-size: 1.1rem;
        }
        
        .achievement-description {
          font-size: 0.9rem;
          margin-bottom: 5px;
          color: var(--text-secondary-color, #666);
        }
        
        .achievement-status {
          font-size: 0.9rem;
          color: #4caf50;
          font-weight: 500;
        }
        
        .achievement-status.locked {
          color: var(--text-secondary-color, #666);
        }
        
        .close-modal {
          margin-top: 15px;
          padding: 12px 24px;
          background-color: var(--primary-color, #4285f4);
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          width: 100%;
          font-weight: 500;
          transition: all 0.2s;
        }
        
        .close-modal:hover {
          background-color: var(--primary-color-dark, #3367d6);
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        /* Responsive improvements */
        @media (max-width: 768px) {
          .main-layout {
            flex-direction: column;
          }
          
          .scoreboard {
            max-width: 100%;
            order: -1;
            margin-bottom: 20px;
          }
          
          .keyboard-key {
            width: 36px;
            height: 36px;
            font-size: 16px;
          }
          
          .word {
            font-size: 2rem;
            letter-spacing: 6px;
          }
          
          .hint-buttons {
            flex-direction: column;
            gap: 10px;
          }
        }
        
        /* Dark mode enhancements */
        .dark-mode {
          --bg-color: #121212;
          --card-bg-color: #1e1e1e;
          --card-inner-bg: #2c2c2c;
          --text-color: #e0e0e0;
          --text-secondary-color: #9e9e9e;
          --border-color: #333;
          --input-bg-color: #2c2c2c;
          --primary-color: #6fa4f5;
          --primary-color-dark: #5e8cd3;
          --secondary-color: #ff9e44;
          --secondary-color-dark: #f57c00;
        }
        
        .dark-mode .keyboard-key {
          background-color: #2c2c2c;
          color: #e0e0e0;
          border-color: #444;
        }
        
        .dark-mode .progress-bar-container {
          background-color: #333;
        }
        
        .dark-mode .difficulty-btn {
          background-color: #2c2c2c;
          border-color: #333;
          color: #e0e0e0;
        }
        
        .dark-mode .close-modal:hover,
        .dark-mode .login-btn:hover,
        .dark-mode .start-btn:hover {
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* Animations and effects */
        @keyframes pulse {
          0% { transform: scale(1); }
          50% { transform: scale(1.05); }
          100% { transform: scale(1); }
        }
        
        .new-game-btn {
          animation: pulse 2s infinite;
        }
        
        /* Notification improvements */
        .notification {
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 15px 20px;
          background-color: #4caf50;
          color: white;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          z-index: 1001;
          animation: slideIn 0.3s ease, fadeOut 0.3s ease 2s forwards;
          max-width: 300px;
        }
        
        .notification.error {
          background-color: #f44336;
        }
        
        .notification.info {
          background-color: #2196f3;
        }
        
        .notification.achievement {
          background-color: #ff9800;
          border-left: 4px solid #f57c00;
        }
        
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
        }
        
        /* Add styles for close icon in achievement modal */
        .achievements-modal {
          position: relative;
        }
        
        /* Improve the achievement close icon visibility */
        .achievement-close-icon {
          position: absolute;
          top: 15px;
          right: 15px;
          background-color: var(--primary-color, #4285f4);
          border: 1px solid var(--border-color, #ddd);
          cursor: pointer;
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          border-radius: 50%;
          transition: all 0.2s;
          z-index: 10;
        }
        
        .achievement-close-icon:hover {
          background-color: var(--primary-color-dark, #3367d6);
          transform: rotate(90deg);
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .achievement-close-icon svg {
          width: 24px;
          height: 24px;
          stroke-width: 3;
          stroke: white; /* Ensure stroke is white for visibility */
        }
        
        /* Make sure the X icon displays properly */
        .achievement-close-icon-x {
          font-size: 24px;
          font-weight: bold;
          color: white;
          margin-top: -4px; /* Adjust vertical position */
        }
        
        .dark-mode .achievement-close-icon {
          background-color: var(--primary-color, #6fa4f5);
          border-color: #444;
          color: white;
        }
        
        .dark-mode .achievement-close-icon:hover {
          background-color: var(--primary-color-dark, #5e8cd3);
        }
        
        /* Keep these separate from fact modal */
        .fact-modal {
          background-color: var(--bg-color, white);
          border-radius: 12px;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
          padding: 25px;
          width: 90%;
          max-width: 450px;
          position: relative;
          animation: modalFadeIn 0.3s ease;
        }
        
        .fact-content {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 15px;
          margin-bottom: 20px;
        }
        
        .fact-icon {
          font-size: 2rem;
          background-color: var(--primary-color, #4285f4);
          color: white;
          width: 60px;
          height: 60px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .fact-text {
          line-height: 1.5;
          font-size: 1.1rem;
          text-align: center;
        }
        
        .modal-button {
          width: 100%;
          padding: 12px;
          background-color: var(--primary-color, #4285f4);
          color: white;
          border: none;
          border-radius: 6px;
          font-size: 1rem;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .modal-button:hover {
          background-color: var(--primary-color-dark, #3367d6);
          transform: translateY(-2px);
        }
      `}</style>
      
      {/* Educational Fact Modal */}
      {showFactModal && (
        <div className="modal-overlay">
          <div className="fact-modal">
            <div className="fact-content">
              <div className="fact-icon">ðŸ’¡</div>
              <div className="fact-text">{factContent}</div>
            </div>
            <button className="modal-button" onClick={() => setShowFactModal(false)}>Got it!</button>
          </div>
        </div>
      )}
      
      {/* Achievements Modal */}
      {showAchievements && (
        <div className="modal-overlay" onClick={() => setShowAchievements(false)}>
          <div className="modal achievements-modal" onClick={e => e.stopPropagation()}>
            <h2>Your Achievements</h2>
            <button 
              className="achievement-close-icon" 
              onClick={() => setShowAchievements(false)}
              aria-label="Close achievements"
            >
              <span className="achievement-close-icon-x">Ã—</span>
            </button>
            
            <div className="achievements-list">
              {Object.values(ACHIEVEMENTS).map(achievement => {
                const isUnlocked = currentUser && 
                                  achievements[currentUser.username]?.includes(achievement.id);
                
                return (
                  <div 
                    key={achievement.id} 
                    className={`achievement-item ${isUnlocked ? 'unlocked' : 'locked'}`}
                  >
                    <div className="achievement-icon">{achievement.icon}</div>
                    <div className="achievement-details">
                      <div className="achievement-title">{achievement.title}</div>
                      <div className="achievement-description">{achievement.description}</div>
                      {isUnlocked ? (
                        <div className="achievement-status">Unlocked (+{achievement.points} pts)</div>
                      ) : (
                        <div className="achievement-status locked">Locked</div>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
